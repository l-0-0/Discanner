1. we just use <form method="POST> for the application with routes, that the user clicks th sub,it button and 
    it goes to another page. for single page apps we don't need form tag. 

2. in our register.js we don't need to put anything in our state. the component makes them with this
    line of code:
    this.setState({
            [e.target.name]: e.target.value,
        });

3. in the code below, returning the qurey means that we don't want to put the catch there, when something 
goes wrong it will catch it later with the main catch
app.post("/reset", (req, res) => {
       const secretCode = cryptoRandomString({
        length: 6,
    });
    db.getPassword(req.body.email)
        .then((results) => {
            console.log("result", results.rows);

            if (results.rows[0]) {
                console.log("i#m already a user");

                let to = results.rows[0].email;
                let text = secretCode;
                let subj = "Reset your password";
                return db
                    .storeTheCode(to, text)
                    .then((results) => {
                        console.log(results.rows[0]);
                        return sendEmail(to, text, subj);
                    })
                    .then(() => {
                        res.json({
                            success: "true",
                        });
                    });
            } else {
                console.log("you're a lier");
            }
        })
        .catch((err) => {
            console.log("error in getting the email ", err);
        });
});


4. passing a funtion to a child-class based component:
    - define a function on the parent
                    toggleModal() {
                        console.log("toggle modal is running");
                        this.setState({
                            visibleUploader: !this.state.visibleUploader,
                        });
                    }


    - bind the function that will be possible to call the this on it:
                    this.toggleModal = this.toggleModal.bind(this);
    
    - call it on the render of the child component in the parent:

                     {this.state.visibleUploader && (
                        <Uploader
                            profileImg={this.state.profileImg}
                            toggleModal={this.toggleModal}
                        />
                    )}

    - on the child component call it with the 'this.props.nameOfTheFunction'. for example in the 
        below example is called on p tag

                    render() {
                        console.log("this.props in uploader: ", this.props);
                        return (
                            <div>
                                <h1>I am the uploader</h1>
                                <p onClick={this.props.toggleModal}>X</p>
                                <input
                                    onChange={(e) => this.handleChange(e)}
                                    type="file"
                                    name="file"
                                    accept="image/*"
                                ></input>
                                <button onClick={(e) => this.handleClick(e)}>submit</button>
                            </div>
                        );
                    }


    
5. when a child make an ajax request, the data from the server goes back first to the parent and the 
    parent send the data to the child via props. 


6. when we make a component we have to render it in the parent to actually see it and make it work. 

7. it's very important not to have the same route name which we put for the (axios-app.get) and the one 
    that we render with it in the parent. if they are the same, we get a json rendered in the browser.

8. when we use props && ...., it means this props should be there and then the next function will be run. 
    for example here: we have to have the people first and then the map starts doing its job!
            {people &&
                people.map((eachPerson, id) => {
                    return <p key={id}>{eachPerson}</p>;
                })}